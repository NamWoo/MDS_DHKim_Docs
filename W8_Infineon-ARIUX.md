 #
 ## W8 - Infineon ARUIX MCU 개발
  - 강사님의 담당업무 : Infineon 기술지원, Automotive software , Autosar, MCAL
  - 이번주 학습목표 : V-cycle


 #
 ## 1일차 - AUTOSAR, V-모델, MBD, Tricore아키텍쳐
  - 학습목표
    1. E/E 중 소프트웨어 접목 분야에 대한 이해
    2. C언어에서 하드웨어 제어 부분 핵심요약
    3. 마이크로컨트롤러의 디바이스 핸들링 방법에 대한 이해
    4. 디버깅과 최적화
  - Automotive 시장 반도체 양대산맥 : NXP반도체(구 모토롤라 반도체사업부) VS Infineon(구 지멘스 반도체사업부) 경쟁구도, 이중에서 Korea마켓에 조금더 점유율이 높은 인피니언에 대해 학습
  - NVIDIA 에서 보드를 출시중이지만, 양산차에 납품되지 않고 있으며 먼 미래의 이야기 정도로 치부됨.
  - 전자제어가 대세가 된 자동차 부품시장에서, MCU와 그에 들어가는 소프트웨어는 매우 중요함.
  - 시스템이란? 시스템의 정의 : X의 입력을 받아 Y의 출력을 내보내는 하나의 집합체로써 : 센서, 액추에이터, 제어기 의 3요소로 구성 됨
  - 자동차의 4대 하위(서브시스템) 시스템 - 각 하위 항목들을 DCU(Domain control Unit) 이라 지칭함
    1. 파워트레인 : 엔진과 변속기로 구성되며 - 실시간성, 낮은 레이턴시가 요구됨, 고신뢰성
    2. 샤시 : 프레임, 조향, 제동, 서스펜션으로 구성됨 - 실시간성, 낮은 레이턴시 고신뢰성 요구됨
    3. Doors, Windows, seatbelt, airbag...등으로 구성 - 가격(단가)가 민감한 영역
    4. 인포테인먼트 - 네비게이션, 차량용 소프트웨어, 계기판등 차량별로 요구수준이 천차만별이며 고급차종일수록 인포테인먼트의 가격비중이 상승함. -> 나머지 3개 분야에 비해 미래시장성이 가장 좋은 분야임.
  - 과거의 자동차들이 기계식을 사용 -> 환경규제에 대응하기 위해 전자장비 탑재가 강제됨
  - DCU는 샤시, 파워트레인, 바디 등의 각각의 서브시스템 전체를 관장함.
  - DCU 기능수행을 위해 하위항목으로 포함된것들은 다음과 같다.
    1. 센서
    2. 시그널 컨디셔닝
    3. MCU 인터페이싱(내부 혹은 외부 ADC)
    4. 전원부 SBC(sys based chip) = 커뮤니케이션 트랜시버 + 볼티지 레귤레이터
    5. 파셜 네트워킹
    6. CAN네트워크(보쉬 제공)
    7. 파워컨섭션 경감을 위핸 내부 FSM기반의 소프트웨어
  - 자동차용 소프트웨어 개발 방법론(혹은 인증) : CMMI, 워터폴, V-model
    - V-model이 업계 대세로 자리잡음
  - [V-모델 추가설명](https://ko.wikipedia.org/wiki/V_%EB%AA%A8%EB%8D%B8)
  - V-모델은 대략 12단계로 세분화 되며 다음과 같다
    1. 모델과 시뮬레이션
    2. 프로토타이핑
    3. 자동 코드 생성기
    4. 임베디드 소픝트웨어 플랫폼(OS)
    5. 통합 컴파일러 디버거 툴체인
    6. 사이클 측정 모델
    7. 개발보드
    8. 디버깅 툴체인
    9. 테스트와 검증
    10. 교정 및 측정
    11. 내구성 테스트
    12. 프로그래머 ㅡ 플래쉬 툴
  - V-모델 대응을 위한 세부항목들의 설명은 아래와 같다. 
    - MBD 기법 : Model based Desine - 동역학 차량 제어 알고리즘 하시는 분들은 C언어 프로그래밍 코딩을 모르는경우가 많기때문에, 이런 간극을 매우기 위해서 자동차 벤더들이 MBD 기법으로 개발을 진행할 수 있도록 제공함, 해당 항목은 차량용 어플리케이션의 
    - AUTOSAR : 차량용 전장부품 및 소프트웨어 표준으로써, 소프트웨어 플랫폼의 복잡도를 감소시킴.
    - ISO26262 : 펑셔널 세이프티, 차량용 전자제어모듈이 갖추어야 할 안전규격
    - SAE J3061 : 보안에 대한 요구사항, 기존에 On-board Comm뿐만 아니라, 차량 외부에서의 통신 및 침입이 가능하도록 
  - 자동차 전장 개발용 핵심 소프트웨어 툴체인 제공 업체 : 일렉트로빗, 이타스, 벡터 
    - soft
    - software configratiol tool
    - auto code Gen
    - 소프트웨어 스텍, 모듈
  - 하드웨어 업체들
    - 인피니언 -> 차량용 하드웨어 소자 제작및 MCU제작
    - 라우터바하 -> TRACE32 제작업체로써 차량용 반도체에 필수 규격임
  - 주목해야 할 보안(시큐리티 업체들)
    - Escript
    - Argus
  - 오토사 맴버사  -> 자동차 쪽 좋은회사들은 오토사 : 어차피 돈내면 맴버가 되니 어떤 레벨인지가 중요, 코어맴버인지, 어느레벨인지 확인
  - AutoSAR 
    - 3단계 : App, BSW(Software flatform)=베이직소프트웨어, RTE, Micro-Con
  - Unit : 테스트 할 수 있는 최소 단위
  - 엘리먼트와 컴포넌트 차이 : 
  - ISO 26262 펑셔널 세이프티 : 세이프티 골(안전 목표) 설정이 중요 
  - HARA : 안전 목표에 대한 시나리오
     - Risk = Severity * 
  - 공부하는법 
    - MCU mannual 3가지 : 처음엔 막막하지만 특성을 알면 쉽게 공부할 수 있어요
      1. 코어 메뉴얼 : 멀티코어 코어가3개, 계산기 역활 코어 - ALU(아레스메틱 로지컬 유닉), 레지스터(제네럴, 스페셜 펑션, 스페셜 퍼포즈)  ->> 코어메뉴얼 : ALU + 레지스터
      2. 프로세서 메뉴얼 : 코어를 제외한 (I/D-Cache)캐쉬, MPU, FPU
      3. 전체 MCU 메뉴얼 : I/O 장치를 위한 메뉴얼 : DI/O, ADC, Timer, Interrupt.... 페리페럴, 페리페럴 컨트롤러
  - ISO26262 : HARA
  - 소프트웨어 유닛 테스팅 : 제조물 책임법 대응 위해서는 최소한도로 ISO 26262 가이드 테스트와 증빙자료가 필요함.
  - TEST가 충분한지 아닌지는 Coverage로 판단 함
    1. statment coverage
    2. Branch Coverage
    3. MC/DC 
  - SAE J3061 : 북미 자동차공학회 스펙 : HARA, TARA -> 시큐리티 적용 이유는 V2X시대로 넘어오면서 어텍포인트가 다양해 지므로 이에 대응하기 위함임.
  - ISO26262 기능안전 표준 또한 시큐리티 정리가 안되어있으므로 안전규격 표준 제정 예정임. 또한 이를 제정하기 위한 하드웨어 구성이 필수적임, 모든 시스템은 하드웨어부터 소프트웨어를 아우르는 기능이어야 완벽한 시스템을 구현할 수 있음.
  - HSM: 시큐리티를 위한 하드웨어 시큐리티 모듈임. 보쉬에서 IP가 제안되었으며 인피니언사에서 실제 탑재 제품을 생산 함.
  - ECU의 정의 : 3가지 요소 
    1. MCU
    2. PERI
    3. Software/Config
  - MCU는 대부분 RICS이며, ARM이 아닌 Tricore이라도 마찬가지로 RISC 적용 됨.
    - 리스크에서는 ALU에 피연산자가 위치해야 하며 메모리의 접근은 로드/스토어 아키텍쳐로 가능함.
    - 명령어 패치와 디코딩이 일정한 길이의 인스트럭션으로 수행됨
    - 로드 스토어 아키텍쳐 : MEMORY와 ALU 사이의 연결다리
  - API VS ABI
    - API : 어플리케이션 프로그래밍 인터페이스
    - ABI : 어플리케이션 바이너리 인터페이스
    - EABI : 스텍 쓰는법, 파라미터 리턴할때, 디버깅할때 최적화할때 등등 사용,
  - 각종 어플리케이션 노트들 다운로드
  - 고장인지 아닌지를 확인 : 
  - RISC : VLE 인코딩 - Veriable Length Encoding : 인코딩 명령어의 길이가 가변적
  - CISC : FLE 인코딩 - Fixed Length Encoding : 명령어 인코딩의 길이가 고정, 32bit
  - 최신은 Thumb-2 ->> 32비트와 16비트 섞여서 사용 : 16비트 사용은 메모리 효율을 위해, 성능 최적화를 위해서는 메모리를 아낄 수 있다. -> 이것은 RISC에서 인스트럭션의 길이가 가변적임.
  - 버스 아키텍쳐 : 하버드 VS 폰노이만 
  - 롬 : 코드 데이터 -> 전역변수, 상수, 명령어, 파라미터, 상수들(텍스트, Bss, 섹션데이터)
  - 노어플래쉬, 낸드플레쉬 두가지 섞여서 사용됨
  - 낸드플래쉬 스테핑스톤 방식으로 부팅 : NOR나 EEPROM 과 같이 Byte단위 Access 가 불가능 하므로, 부트 시퀀스가 필요함.
  - 낸드 플래쉬 메모리 : 가성비가 좋음 스테핑 스톤
  - 노어 플래쉬 : 메인메모리, 바이트단위 접근 가능
  - RAM : Ramdom access 의미 : 0번지 접근속도 = 1번지 접근속도 = 10000000000번지 접근속도 = 999999999999999번지 접근속도 같다. 어떠한 주소값이 주어지더라도 할당되어있다면 해당 주소의 데이터에 접근하는 속도는 같은것이 랜덤 엑세스의 의미
  - DRAM과 SRAM : 근본적으로 DRAM은 캐패시터에 전하가 충전되는 구조고, SARM은 반도체 소자로만 이루어져 있으므로 저장밀도는 DRAM이 높고 SRAM은 고속 고성능이지만 용량에 한계가 크다.
 #
 ## 2일차 - 소프트웨어 빌드 

 링커 
 .o파일은 리로케이트가 필요 정리안해주면 실행안됨 바이너리 파일을 구성하는 일 부분
 .elf는 실제로 실행 가능한 파일
 여러개를 묶고 어떻게 사용할지를 
 링크스크립트는 쉬운데 하드웨어를 기반, MCU가 어떻게 동작하는지를 이해하고 있으면 쉽다. 하드웨어 지식이 필요하고 단순한 컨셉을 이해하고 있어야해요
 링커스크립트는 컴파일러마다 다 다르기때문에 ->> GCC의 xx.ld 파일 ->> GCC는 ld의 스크립트 
 .ld를 알고있으면 굉장히 좋아요 임베디드 컴파일러는 매우 다양하므로, 
 ```
 변수이름 : LM_LICENSE_FILE
 변수 값 : 7594@192.168.101.26
 ```


   Trace32 사용법
 어드레스/라인 : 버추얼 메모리의 어드레스, 라인은 : 텍스트 에디터로 볼때의 라인 넘버  
 코드 : 머신코드-> 머신 랭귀지에 대한 코드 인코딩 방법이 정해져있어서 디스어셈블 해주는거야
 어셈블러와 기계어는 1:1 매칭 - 변환과 역변환이 항상 동일하다.
 디버거쪽은 무조건 16진법을 사용 함. -> 16진법 2진법 10진법 변환이 빨리빨리 되야됭
 4자리 인스트럭션 : 16비트, 2바이트 - 16진수 인스트럭션 - THumb2 명령어
 8자리 인스트럭션 : 32비트, 4바이트 - ARM 명령어
 라벨/ 심볼 : 함수명, 함수의 타입 , 함수명은 주소 - 심볼 라벨 레이블로 표현이 됨
   - 호출할때 () 사용 :  펑션 콜 오퍼레이터 : jump SP/PC 
 니모닉 : 어셈블 문법으로 이루어진 ??
 주석으로 디버거가 분석해서 이거는 여기로 뛰는거야 정보들을 계산해서 제공해줌
 메모리 덤프 기능 70000000 치고
  메모리 덤프 창에서 -> 누르면 
 ld버튼을 누르면 메인함수 입구에 가져다 놔
  list auto 에 대한 설명
   - Mode 버튼을 누르면 하이레벨만 보기/ 
   - 
   - 
   - 
   - 
   - 
   - 
   - 
   - 
   - 
   - 
   - 
   - 
   - 

   라이브러리 만들어야하는경우, 프로젝트 재활용할때마다, 
  psb라는 페리페럴 버스와 연결되는 버스
  로드 스토어를 통해 LED를 켜고 끔, 이를 로드 스토어 명령어라고 하며, 하드웨어가 메모리 맵드 IO임.

  세부적인것들은 파이프라인이, 

  p버전, 퍼포먼스 버전,
  E버전 클럭이낮지만 전력소모가 줄음, 하드웨어구조 다름
  왜 이렇게 만들었지??
  연산을 해요 
  PC = 프로그램 카운터 - 지금 실행하는 명령어의 주소가 담겨있음
  SP = 스텍 포인터
  RA = 리턴 어드레스



  https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B

  * : 인다이렉터 어드레스 오퍼레이터
  인터럽트 벡터 테이블
  인터럽트 운영 : 
  ICR, 
  플렉서블한 인터럽트 운영
  벡터테이블이 필요함 : 인터럽트 벡터 테이블, 플렉서블하게 쓸 수 있고, 255개의 우선순위와 인터럽트 등록가능,
  벡터테이블은 명령어의 테이블임. 명령어 딱 고정된크기, ISR 직접 제공불가능하고, 진짜 ISR로 점프코드가 들어가 있음.
  주소만들고 ㅋㅀ
  명령어를 담아놓는 테이블을 벡터테이블
  ISR을 ㅏㅁ늘
  B코어는 A코어가 쓰는 메모리 
  A10이 스텍포인터 푸쉬팝
 

 #
 ## 3일차
  - 로어컨텍스가
  - 익스플리시트 하게 
  - 어셈블리로 작업
  - 시스템 프로그래밍
  - CSA : 컨텍스트 세이브 에이리어 :  링크드리스트로 만들어쓰는 특수기능, 자동도 수동도 있다. 
  
  - EABI 에 대하여
    - [ABI 에 대한 설명](http://jake.dothome.co.kr/abi/)
    - [EABI ](http://forum.falinux.com/zbxe/index.php?document_srl=574604&mid=lecture_tip)
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
    - []()
    - 링크드리스트로 관리해서 프리한노드 리미트노드 어디냐의 포인터정보로 관리
    - 디버거 레지스터 PCX I



    - 펑션 프로토타입 : 하나의 스코프로 
    ```c
    extern void engine(int a, int b)
    오랫동안 
    ```
    -goto문 사용하지 않기











    
