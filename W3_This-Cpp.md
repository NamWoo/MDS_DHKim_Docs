
[이것이 C언어다] 완독 후 핵심정리 & 독자서평
====
> # Linux 개발환경 구축
   > ## C++11 표준 사용으로 GCC 사용안함. VC 컴파일러 사용

> # Windows 개발환경 구축
   > ## Visual Studio 2015 ★ (편하고 편하다..)
   > ## 윈도우 유저라도 Git은 사랑입니다 

> 저자가 추천하는 C++을 공부하기 전 자가테스트 : 자신의 C 이해도 점검 (6p, 책 서두 참조)

> C언어 사전지식 필요함, 저자의 유투브 강의 추가 참고 [https://www.youtube.com/channel/UCdGTtaI-ERLjzZNLuBj3X6A]  

# 0.INDEX
 * 이것이 C++다 (최호성님 저서) 학습 후 학습내용 복습겸 정리와 서평 입니다.
>>
    1. C와는 다른 C++
    2. C++함수와 네임스페이스
    3. 클래스
    4. 복사 생성자와 임시 객체
    5. 연산자 다중 정의
    6. 상속 기본
    7. 상속 심화
    8. 수평적 관계와 집합 관계
    9. 템플릿
    10. 예외처리
    11. 객체지향 주소록
    12. 못다한 이야기와 앞으로 해야할 것

  
# 1. C와는 다른 C++
  
 * 인스턴스 : 객체지향에서 "생성한 변수명" 을 새롭게 정의
  ```cpp
     //From C언어
     int a; // a:변수명

     //From C++
     int a; // a:인스턴스
     
     //int 가 자료형이긴 한데 C++에서는 "객체 혹은 클래스"라는 자료형이 추가된다.
  ```
 * C++ 스럽게 변수를 새롭게 초기화하는법 
  ```cpp
     //From C언어
     int a = 10; // a:변수명

     //From C++
     int a(10) // a:인스턴스
  ```
 
 * 메모리의 동적할당은 new와 delete연산자를 사용! (43p)
 * auto : 컴파일러야! 인스턴스의 자료형을 알아서 결정해줘 ->> C언어에 비해서 auto 키워드의 기능이 변경됨!(41p)
 * 참조형 변수 : 포인터를 좀더 쉽게 쓰게해주는 자료 처리 방식
 * 호출자만 보고는 함수 원형을 절대로!!! 예측할 수 없다(48p)
 * r-value 참조 : 임시결과저장소 생성을 막아 프로그램 성능 향상(51p)
 * 범위 기반 for : 배열 요소 수 를 가지고 for문을 반복횟수를 자동결정(52p)
 * 나의 Insight : C++언어 페러다임 2가지 = 협업( =대규모 프로그램 ), 객체지향 프로그래밍( OOP )
 * auto예약어의 의미 : 초기값에 맞춰 인스턴스의 형식을 컴파일러가 알아서 결정
 * 배열로 메모리를 동적할당하고 해제하는 코드 -> new, delete 키워드 사용
 * 1장 연습문제 (54p) 풀어보기 -> 이하 내용
  
 # 2. C++함수와 네임스페이스
 * 디폴트 매개변수 : 함수에 파라미터가 없을 때 사용할 기본값을 설정합니다 (59,60p) 
    - 장점 : (사용자 입장에서) 함수 호출 시 파라미터를 생략하고 함수를 호출 할 수 있습니다.
    - 단점 : 호출자의 코드만 봐서는 함수의 원형을 추측하기란 불가능하다. (모호성이 증가한다)
    - 여기서 다시한번 C++의 철학을 느낄수 있습니다 협업중심(대규모) -> 클래스를 디자인한 사람과 함수를 사용하는 사람이 다를 수 있다.
 * 함수의 다중 정의: 이름은 같지만 매개변수 구성이 다른 함수를 정의합니다.(Polymopism,64p)
    - 다중 정의는 모호성을 유발한다 위험함(67p)
 * 함수 템플릿 : 함수의 다중정의는 책임이 따르지만, 사용자의 편의성과 확장성에 이점이 있다. 이들의 장점을 결합한 형태가 함수템플릿(68p)
 * 인라인 함수: 함수와 매크로의 장점을 모았습니다. 코드사이즈(라인의 수)가 작으면서 && 빈번하게 호출이 일어나는 함수의 경우에 사용하면 성능상의 이득이 있다(71p) 
    - C언어의 레지스터 키워드와 비슷하게, 모든 함수에 인라인키워드를 붙인다고 되는건 아니고, 컴파일러가 결정한다. 프로그래머의 키워드는 오직 요청의 의미이다.
 * 네임스페이스: 대규모 프로그래밍 시 유용한 것으로 함수, 변수 등에 소속을 부여하고 보다 체계적으로 관리할 수 있습니다. (75,76p)
 * 네임스페이스의 특징(장점) 
    - 동일한 이름의 함수가 반복될 수 있다. 변수 함수 클래스 등을 묶어서 범주로 볼 수 있기 때문에 대규모 프로젝트를 진행하거나 협업체계 구축에 사용할 때 매우매우 좋다. 
    - 네임스페이스 안에 또 다른 네임스페이스가 속할 수 있습니다.
 * 식별자 검색 순서 : 식별자가 선언된 위치를 검색해 나가는 순서(시퀀스,84p)
    - 전역함수인 경우, 클래스 매서드인 경우에 관해 특징이 잘 정리되어있음 (84p)

# 3. 클래스
 * 용어정리
    * 클래스(Class) : 함수를 멤버로 갖는 구조체의 확장판(객체 지향을 지원하기 위해서) 
    * 객체(Object) : 클래스를 통해 만들어진 대상 (클래스가 자동차공장이라면, 객체는 빨간차 노란차 파랑차)
    * 매서드(Method) : 객체지향에서의 함수
    * 인스턴스 : 자료형으로 생성되어, 메모리에 공간을 할당받은 친구
    * 결론 : 객체지향적 사고방식으로 다 바꿔라! 사고방식을 생각하는 방법을! 용어를!!
 * C언어에서 C++스타일의 클래스를 이해하는 과정 : 104p ->106p
    * 104p와 106p의 차이점
       1. 접근제어 지시자가 등장
       2. 함수를 (구조체->클래스) 맴버로 포함 할 수 있다.
       3. 식별자 검색 순서 이슈 발생함
 * 접근제어 지시자 : 3P (115p)
 * 생성자와 소멸자: 클래스 객체가 생성, 소멸할 때 ‘자동으로’ 호출되는 함수이다.(123p)
    - 자동으로 생성되므로, 초보 프로그래머가 이로 인해 실수할 가능성이 높다!! 생성자 소멸자의 보이지않는 호출 이슈는 두고두고 공부해서 정리해놓자!!! ★★★★★★★★★★★★★★★★★★★★★★★★★
 * 객체(클래스)형태 또한 자료형의 일부이기에 배열로 사용할수 있고, 이때 배열로 생성한 객체를 반드시 배열로 삭제해야 한다(127p)
 * 생성자 초기화 목록(default initializer) ★★★★ (128,129p)
 * 생성자 다중 정의 : 생성자를 다중 정의할수 있다(130p)
    * but 모호해질 가능성이 있으므로 생성자 위임기능을 사용하자
    * 명시적 디폴트 생성자(Expilcit default constructor..??) (134p)
 * 메서드: 함수 형태로 크래스의 실제 동작과 상태를 책임진다.
    * 매서드의 종류와 특징 (138p)
 * this포인터 : 작성중인 클래스의 실제 인스턴스 주소를 가르키는 포인터! 
    * 클래스는 주소가 없다 인스턴스에게 주소가 있을뿐
    * 마치 C언어에서 int자료형의 주소를 나타낼 수 없는 것처럼 말이다..
    * &(NameofInstance)로도 동일한 기능을 수행하지만, 실수 방지를 위해 클래스차원에서 This포인터를 리턴받아 사용하는것이 C++스타일에 적절
 * ★★★ Stringctr 만들기 실습 꼭 해보기!!!!★★★(147p)
 * 상수형 메서드: or상수화된 메서드는 맴버 변수에 읽기 접근은 가능하지만 쓰기는 허용되지 않은 메서드를 말함(159p)
    * 상수형 메서드의 특징: This포인터를 상수형 포인터로 변경(160p)
    * 상수형 메서드는 절대로 멤버 변수의 값을 쓸 수 없고, 상수형 메서드가 아닌 멤버는 호출 할 수 없다.(161,176p)
    * Const 키워드는 C++ 실력을 평가하는 척도이다자 쓸수 있는곳에서는 최대한 활용하자(162p)
    * 상수형 메서드의 예외사항 (163p) : mutable키워드
 * 맴버 함수의 다중 정의 : 메서드 또한 다중 정의가능하며, 클래스에 특화하여 생각해 볼 문제
 * 정적 멤버: 문법적으로는 정적 ‘멤버’지만 실제로는 전역 변수나 함수같은 성격을 보인다.(171p)
    1. 정적 맴버는 인스턴스 선언 없이 호출 할 수 있다.
    2. 정적 매서드는 This포인터가 없다
    3. 정적 변수는 반드시 선언과 정의를 분리한다
    4. 정적 변수는 동시성(멀티스레드 프로그래밍)지원이 불가능하다 꼭 필요한경우에만 사용하도록

# 4. 복사 생성자와 임시 객체
 * 복사 생성자: 객체의 복사본을 생성할 때 호출되는 생성자이다. 프로그래머가 의도하지 않았지만, 컴파일러가 필요에 의해 묵시적으로 호출하는 경우가 많으므로, 성능하락을 피하기 위해서는 특징을 잘 알아 두어야 한다.(181p)
    * 문제가 생기는경우 : 클래스 내부에서 메모리를 동적 할당 및 해제하고 이를 멤버 포인터 변수로 관리하고 있는 경우
    * 문제가 되는 이유 : 객체 하나로 끝날것을 두개를 생성하여 처리함, 복사 생성자 호출, 소멸자까지 호출 메모리와 CPU의 자원을 낭비하는 결과
    * 해결책 : 1.복사 생성자 삭제 , 2.참조자를 사용해 클래스를 복사하는것이 아니라 클래스의 주소를 이용해서 문제를 해결 (185p)
 * 상수형 메서드(188p)
 * ★★★★★깊은 복사와 얕은 복사★★★★★: 실제 값을 두 개로 만드는 깊은 복사와 값은 하나이나 포인터만 두 개를 생성하는 얕은 복사의 차이를 배운다.(192~195p)
 * 대입연산자

 * 임시 객체: 컴파일러가 임의로 생성했다가 바로 소멸시키는 객체.
 * 이동 시맨틱: 임시 객체가 생성됐을 때 부하를 최소화 하기 위한 문법으로 C++11부터 지원한다.



# 5. 연산자 다중 정의
 * ★★제5장 연산자 다중정의 2강★★ ->> 인강을 들어도 모르겠음 나중에 듣기
 * ★★독하게 시작하는 C프로그래밍 15장 ->> 컴파일러 최적화에 대한 내용 참조하기
 * 생성자(Constructor)에 대한 복습
    1. 이름없는 임시객체에 대하여 주의를 기울일것
    2. 생성자에 대한 완벽한 이해와 위험성을 인지해야한다(이해하지 못할경우, C++의 높은 경지에 오르지 못한다)
    3. 예외처리에 대한 로직 또한 고민해야 한다.
 * 연산자 함수: 연산자를 이용하듯 호출할 수 있는 메서드. 사용자 코드에 보이는 연산자(예를 들어 ‘+‘연산자)가 실제로는 함수이고 사용자가 직접 그 의미를 구현하는 문법이다.
    - 절대로 논리 연산자들을 다중 정의해서는 안된다(235p)
    - 연산자 함수도 다중 정의 할 수 있다.
    - 연산자 다중 정의: 필요에 따라 연산자 함수를 다중 정의하는 것.
 * 댕글링 포인터 문제 발생 스터디하기
 * 포인터 엘리어싱문제 (244p)
 * 대입 연산자 오버로딩 시 주의할점 두가지
    1. 자기자신 대입연산에 대한 예외처리
    2. 포인터 엘리어싱 발생위험 인식
    
# 6. 상속 기본
 * 상속이 필요한 이유 = C++의 설계이념 = 대규모(협업), 객체지향의 도입
 * 상속을 통해 얻는 가장 큰 이득 : 모듈화 프로그래밍
 * 모듈화 프로그래밍 4가지 요점
    1. 모듈화되어있지 않다면 발생할 문제 : 클래스(객체간) 의존관계 순환에 의한 무한 버그발생 = 땜질처방 Side Effect 심화로 인해 무한대의 야근
    2. 가능하다면 프로젝트 Drop보다는 Refectoring 추천 (건축 비유 : 재건축 보다는 리모델링) ->> 이를위해서 의존관계 및 상속관계를 파악해야 함.
    3. 설계규칙은 SOLID하게! (518p참조)
    4. 3가지 구별은 명확하게 : UI, DATA, CONTROL
 * 상속: 객체단위로 코드를 재상용하거나 확장, 개선하는 방법
    * 파생 클래스의 인스턴스가 생성 될 때 기본클래스의 생성자 또한 호출됨
 * 매서드의 재정의: 함수(매서드)의 기존 정의를 새롭게 바꾸는(혹은 대체하는) 방법이다.
    1. 일반 : 접근형식
    2. virtual : 실형식을 따른다
    3. static
    (추가예정 - 글을 쓰는 이 시점에 나의 이해도가 떨어짐.)
 * 상속에서의 생성자와 소멸자 : 생성자의 호출순서는 실행순서와 반대이다(콜 스텍을 보고 판단하면 도움이 된다)
 * 절대 하지 말아야 할 행동!! : 생성자 함수에서는 객체 자신을 초기화해야한다.
    * 파생형식 생성자에서 부모 클래스 맴버를 초기화 하면 큰일이 난다.
    * 이유 : (추가예정)

# 7. 상속 심화
 * 이 챕터가 오롯이 가상함수를 위해 존재한다. 저자께서 매우매우 강조한 부분. (C언어에서 함수 포인터 부분을 참조하기 추천함)
 * 가상 함수: virtual 예약어를 앞에 붙여서 선언한 메서드이다.
 * 가상 클래스: 가상 함수를 가진 클래스이다.
 * 가상함수 테이블 : (추가예정)
 * 순수 가상 클래스 : (추가예정)
 * 추상자료형 : (추가예정) 다중if문 대체가 가능하다
 * 다중 상속: 한 클래스가 두 개 이상의 클래스를 동시에 상속받는 경우이다.


# 8. 수평적 관계와 집합 관계
 * 클래스간의 관계를 정의하고 기능과 구현범위를 나누는것이 C++설계원칙이다.
 * 기능과 구현이 아닌 구조적이며 객체지향적인 사고로 클래스간 관계를 설계해야 한다. (MECE구조를 참조하면 좋을꺼 같다.)
 * C++언어는 자유도가 높다. 자유만큼의 책임과 실력을 요하는 프로그래밍 언어이다.
 * friend 함수 및 클래스: 클래스에서 선언하는 접근 제어 지시자의 영향을 받지 않고 모든 멤버에 접근할 수 있다. 함수나 클래스에 대한 선언이다. 
 * 집합 관계: 여럿이 모여 새로운 하나를 이루는 경우를 말하는 것이며 인스턴스가 소멸하면 다른 구성요소들 또한 모두함께 소멸함



# 9. 템플릿
 
 * 클래스 템플릿 : 클래스를 만들어내는 틀(결국 본질은 템플릿)
 * 함수 템플릿 : 함수를 만들어 내는 틀(결국 본질은 템플릿)
 * 템플릿 클래스 : 클.템으로 만들어진 클래스를 지칭(결국 본질은 클래스)
 * 템플릿 특수화 : 특정 형식에 대해서만 다른 코드를 적용하기 위한 템플릿 문법.
 * 스마트 포인터 : 동적으로 할당한 인스턴스를 자동으로 삭제해주는 편리한 포인터 4가지 종류가 있지만, 의미있게 사용할 수 있는 포인터는 두가지(shared, unique)
 * Stack unwinding문제 (430p)


# 10. 예외처리
 * 예외 처리 기본: try, throw, catch문을 중심으로 예외처리를 구성하는 방법.
 * 스택 풀기: 예외 발생시 여러 함수로 인해 증가한 스택을 한 번에 정리할 수 있는 기능.
 * 메모리 예외 처리: 객체가 생성 혹은 소멸하는 과정에서 발생하는 예외를 다루는 방법

# 11. 객체지향 주소록
 * 책을 온전히 공부했다 안했다의 판단 기준. 
 * 혹시라도 한방에 성공하지 못한다면 책을 보고 따라하는것만으로도 도움이 된다.
 * 언젠가는 처음부터 끝까지 모든것을 해낼 수 있어야 한다.

# 12. 못다한 이야기와 앞으로 해야할 것
 * STL : 코드호환성을 위해 필요함 :: 책추천: 뇌를 자극하는 C++ STL 
    * URL : http://www.hanbit.co.kr/store/books/look.php?p_code=B5912645820
 * 람다식 : (추가예정)
 * 디자인 패턴 : 효율적인 프로그래밍을 위한 설계기법

## 고수가 되기위해 필요한 책
 1. GoF의 디자인패턴
 2. Effective C++
 3. Effective Modern C++
 4. The C++ Programming Language
 5. 뇌를 자극하는 C++ STL
 6. 자료구조/알고리즘 공부는 항상 중요


## 서평 : 
 
 * 서평 : C++를 처음 배우는 입장에서 조금 난이도가 어렵다고 느껴지는 책이다.
 난이도와는 별개로 저자의 의도는 C++를 정말 본격적으로 잘 하기 위해서 필요한 부분과, 추상화에 가려져서 차마 인식하지 못한 부분을 정확하게 파고들어서 좀더 좋은 프로그램을 만들 수 있는 가이드라인을 제시해 주는 책이다. 기본적인 프로그래밍 실력이 탄탄한 가운데(특히 C언어의) 저자의 유투브 강의 [https://www.youtube.com/channel/UCdGTtaI-ERLjzZNLuBj3X6A] 와 함께라면 노력해서 단기간에 C++의 많은것을 배울 수 있는 책 이라고 생각한다.
 * 가장 중요한 사항 : 나는 아직 이책에 대해서 서평을 쓸정도의 이해도를 달성하지 못했다.