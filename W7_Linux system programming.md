#
# W7 Embedded Linux 교육 요약
   - 이 문서는 W7 Linux system programming 7주차 교육과정에 대한 정리한 문서 입니다.
 ## overview
   1. C언어 코드의 실행과 런타임
   2. 리눅스 부팅
   3. vim에디터
   4. 쌈바! samba protocol
   5. C 표준라이브러리
   6. 리눅스 시스템 콜
   7. make 컴파일 자동화
   8. gdb 그누 디버거
   9. 파일입출력
   10. 표준입출력
   11. 폴더와 파일 그리고 권한
   12. 프로세스와 쓰레드
   13. 파이프통신과 네트워크 통신
   14. system V ipc 표준통신 3요소 - 큐 세마포어 공유메모리
   15. 소켓프로그래밍
 #
 ## OT
   - 효율성 높은 학습을 위해서 리눅스 시스템 프로그래밍 하는 동안에 리눅스마스터를 공부한다 -> 주중에 학습하는것 복습하고 내것으로 익히는데도 벅차서 실패함
   - sudo su/sudo -s : 루트 계정으로 전환
   - ifconfig eth8 192.168.0.2 : 네트워크 어댑터를 지정 IP주소로 변경
   - SAMBA 설치하여 Host에서 Target에 파일 전송 손쉽게 하기
     1. SAMBA 설치
     2. ip-addr/root 네트워크 드라이브 추가
     3. root/home/(accname) 으로 학습용 파일 및 교보재 이동
     4. tar -xzf (filename) : tar파일 풀어놓기
   - 환경변수 : echo @path
     - 리눅스 쉘 환경과 프로그래밍 소개
   - C 표준 라이브러리 소개
     - assert.h, ctype.h, errno.h, float.h .... 많음
     - 위키피디아 C 표준라이브러리 문서 참조 [참조링크](https://en.wikipedia.org/wiki/C_standard_library)
   - makefile에 관하여 학습
   
 #
 ## Day1
   - What is system call is? in Linux system : System call is APP(user)의 권한이 모자란 경우 OS(시스템 혹은 커널에게 동작수행을 요청하는것)
   - Startup sequence : main() 함수의 Entry에 대하여 : 디스크에 존재하던 프로그램이 실행되어 프로세스가 되기 위해서는 세가지 메모리 세그멘테이션을 복사해야 하는데, .text, .data, .bss 영역 세가지 이다.
   - 스텍은바닥부터 힙은 천장부터 잡혀간다.
   - 실행파일은 두가지로 분류가 된다. 디버깅 가능 실행파일: ELF, 디버깅 불가능 실행파일 : Bin
   - 임베디드 시스템(ARM에서) 리눅스 부팅을 위해서 기존 NOR 플래쉬가 필요하던것을 개선하여 NAND와 DDRAM 만으로 부팅할 수 있게 시스템을 구축 하였고(MDS2450보드에서), 이를위해 0x000~번지에는 iROM이 존재한다.
   - 현용 system NAND에서 리눅스 커널부팅을 위해서는 크게 3가지가 필요하다
     1. U-Boot
     2. zImage
     3. root filesystem
   - 기본적으로 Nano , vi 에디터는 대부분의 임베디드를 포함한 리눅스배포판에서 지원하므로 해당 두가지 툴은 필수적으로 익혀두자
   - vi(vim) 에디터에 관하여
     - 화살표 이동 명령어 4종
       1. h : 좌
       2. j : 위
       3. k : 아래
       4. l : 우
     - 단어단위 이동 명령어 3종
       1. w : 다음단어 첫문자
       2. e : 다음단어 마지막문자
       3. b : 이전단어 첫문자
     - 줄단위 명령어이동 
       1. f -> e : 줄 내 가장빠른 e 로 이동
       2. f -> x : 줄 내 가장빠른 x 로 이동
     - 삭제 명령어 4종
       1. x : 한문자 삭제
       2. dd : 한줄 삭제
       3. dw : 한단어 삭제
     - 되돌리기
       1. u : 변경 내용 되돌리기
   - 추가로 공부할것
     1. 정규 표현식
     2. SED
     3. make파일
     4. ARM 어셈블리어
   - ARM 표준 라이브러리 -> 매우많음, 다 알기는 힘들고 자신이 필요할 때마다 검색해서 찾아 쓰는 능력이 필요함.
   - make : 빌드 자동화 툴
   - 시스템 콜 : 하드웨어 접근 등의 커널권한이 필요한 작업을 유저어플리케이션에서 수행할 때, 커널에게 요청하기 위해서 필요하다.
      - File open(저수준)이 바로 시스템 콜 함수이다.
   - 리눅스 시스템 프로그래밍 : 리눅스 시스템이 제공하는 파일 시스템이나 정보 시서템 정보 등 다양한 커널이 제공 해 주는 서비스를 이용 할 수 있도록 학습하는것이 목표인 과목
   - 시스템 호출 : 유저 어플리케이션에서 수행할 수 없는 작업(파일IO, 하드웨어 관련 작업)을 수행하기 위해서 "커널이 제공하는 서비스 이용하는 행위-함수호출"를 시스템 호출이라고 한다
   - C표준 라이브러리 : C언어와 유닉스는 동시에 제작되었으며, 서로가 서로룰 위해 만들어진, 떼어놓을 수 없는 관계라 리눅스에서는 C언어 표준 라이브러리 학습하기 최적의 최고의 OS이다.
 #
 ## Day2 - 리눅스의 라이브러리
   - 리눅스에 존재하는 3가지 라이브러리 : 정적, 동적, 공유 라이브러리
   - 각 라이브러리 별 특징 및 구분점 소개
     1. 정적 : .a를 확장자로 가짐, 컴파일시 적재되므로 유연성이 떨어지며, 바이너리 크기가 커짐
     2. 동적 : 프로그램에 탑재되어있지 않고, 실행되다가 필요시 적재, 플러그인 모듈 구현에 적합
     3. 공유 : 프로그램이 시작될 때 적재, 어려 파일이 동일한 라이브러리를 공유하므로 메모리를 아낄 수 있다.
   - 리눅스의 라이브러리들은 관용적 접미사 lib를 붙인다.
   - 정적 라이브러리는 링크 단계에서 연결된다.
     - 만약 링크에 실패하는 경우 링커에서 에러를 발생시키며, 내용은 undefined reference to~ 의 에러가 발생한다.
   - 응용 프로그램 빌드 
   ```shell
    gcc -c mylib.a mylib.o
    ar rc mylib.a mylib.o
    gcc -c main.c
    fcc -o main main.c -L ./ mylib.a
   ```
   - 공유 라이브러리 : 정적라이브러리의 리던던시(redundency) 문제를 해결하기 위해서 만들어짐
   - 리던던시란, 여러개의 프로그램이 동작할때, 동일한 내용의 코드를 여기저기서 중복되게 로드하여 쓸때 발생하는 메모리의 낭비를 의미합니다.
   - 공유 라이브러리 활용시 -ldl 옵션을 사용하여 컴파일 해야 합니다.
 #
 ## Day3 - FILE
   - Everything is file : 유닉스(리눅스) 에서는 모든것을 파일로 취급한다
   - 네트워크 카드, 사운드, 키보드 모니터를 포함한 모든 하드웨어 또한 파일의 형태로 다룬다.
   - 파일 Open, Read, Write, Close 4가지의 오퍼레이션(동작함수)가 존재
   - 파일형태로 관리하는것은 모두 위 4가지의 조합으로 핸들링함.
   - File Operations : 
   - 요건 몰랏지? 파일로 관리하는 것들 : 소켓, IPC, 하드웨어 장치(GPIO), 파이프
   - File open(저수준)은 시스템 콜 함수이다 
     - 시스템 콜 : 하드웨어 접근과 같은 커널권한이 필요한 작업을 유저어플리케이션에서 수행할 때, 커널에게 요청하기 위해서 필요하다.
   - file discriptor : 파일 open 의 리턴 값, 프로세스를 새로이실행할 때 마다 기본 자동적으로 3개씩 생성됨 (0,1,2)
     - 0 : std in
     - 1 : std out
     - 2 : std err
   - file open read/write에 관한 기본 예제 진행
   - fsync : Data와 MetaData를 동기화 함
     - 동기화의 대상은 메모리-디스크(스토리지)간에 동기화를 의미함
   - Direct I/O
      I/O 퍼포먼스 향상을 위해서, 사용자공간과 I/O버퍼를 직접 연결하는 기법 
   - 파일의 본질은 i-node
   - 링크는 하드링크와 소프트 링크가 존재 한다.
   - Redirection
     - 스트림(파일 디스크립터로 연결된 노드 투 노드)을 다른곳으로 옮기거나 동일하게 복사하기 위해서는 dup함수 활용
   - 파일입출력은 저수준과 고수준 파일 입출력 두가지 형태로 접근이 가능하다.
   - 문자열 기반 입출력을 위해 존재하는 함수로는 fgetss(), gest() 함수를 사용할 수 있다.
      - fgetss() : 널문자가 나오기 전까지 동작하며 개행문자, 공백문자는 문자로 인식한다.
      - gest() : 널문자, 개행문자, 공백문자가 나오기 전까지 동작한다, 해당하는 문자를 만나면 리턴한다
   - 형식기반 출력함수는 printf, fprintf, sprintf등이 존재한다
   - 리눅스에서의 저수준 파일 입출력 함수 정리
   ```c
   ```
   - 리눅스에서의 고수준 파일 입출력 함수 정리
   ```c
   ```
   - 저수준과 고수준 파일 입출력 비교 장표
   - ![제작중..]()
 #
 ## Day4-1 - 프로세스와 스레드
   - 프로세스의 정의 :  현지 실행중인 프로그램
   - 프로그램과 프로세스의 차이 
     - 프로그램 : 하드디스크(스토리지 스페이스)에 존재하며 힙과 스텍영역이 없음
     - 프로세스 : 메모리에 존재하며 힙과 스텍영역이 존재 한다. 프로그램이 실행되면 프로세스가 되는것
     - 프로세서 : CPU를 의미함. 프로세스를 실제로 돌려주는 하드웨어(이름이 비슷하므로 혼동에 주의하자)
   - 프로세스의 확인 명령어 : ps
   - 스크립트 언어로 제작된 프로그램은 사전에 컴파과 비슷한 별도의 과정 없이 실행시마다 코드를 읽어서 실행하는데, 이런 방식을 인터프리터 형식의 언어라 지칭한다.
   - 프로세스는 메모리상에 존재하며, 크게 4가지로 분류된다
     1. 텍스트
     2. 데이터
     3. 힙
     4. 스텍
   - 리눅스에서 현재 실행중인 프로세스의 목록을 보려면 ps 명령어도 있지만 TOP 명령어 사용을 추천 함.
   - 프로세스 식별 함수
   ```c
   ```
   - 프로세스 실행타임 측정 : times() 사용
   - 환경변수 사용 : 프로세스가 실행되는 기본 환경은 환경변수로 정의되어있다 (예를들어 vim 하면 편집기가 실행되고, gcc 하면 컴파일러가 실행되는것이 모두 환경변수덕분에, 환경변수를 쉘이 알고 있어서 누릴수 있는 행복이다.)
   - 메인함수 또한 메인함수만의 환경변수(입력 파라미터)를 받아 활용할 수 있다.
   - 환경변수 사용을 위한 명령어 : printenv, env, setenv 등등...
   - 환경변수 관련 함수
   ```c
   getenv()
   putenv()
   setenv()
   unsetenv()
   ```
   - 프로세스의 환경과 실행 : tnpf
   - 쉘이란? 
     - 리눅스 혹은 유닉스 시스템에서 운영체제와 커널 사이에 이용자의 명령을 해석하고 그 처리 결과를 시용자에게 돌려주는 시스템 프로그램
   - 알아야할 기능별 함수 정리
     - 프로세스 생성
       - 프로세스 실행 : fork(), vfork()
       - 프로그램 실행 : system()
     - 프로세스 종료
       - exit(), _exit(), atexit()
     - exec함수군
       - 시스템 디펜던시함
     - 프로세스 동기화
       - wait(), waitpid()
 #
 ## Day5 시그널과 파이프 , IPC
   ### 시그널
   - 시그널은 소프트웨어 인터럽트로써 프로세스 내부에 비동기적인 이벤트 발생을 알려주는 메시지
   - 알아야 할 함수군 집합 정리
     1. 시그널 보내기 kill, abort...
     2. 시그널 핸들러 등록 signore...
     3. 시그널 집합 sigfillset...
     4. 시그널 제어 sigaction...
     5. 시그널 타이밍 관련 alarm, gettime, settime...
     6. 기타등등 psignal, sighold...
   - 시그널 처리방법
     1. 프로세스가받은 시그널에 따라 기본동작 수행
     2. 프로세스가 시그널을 마크하거나 재정의해였다면 프로세스의 의도대로 시그널 동작 
   - 리눅스 유닉스 시스템의 시그널 정리표
     - OS 디펜던시 한 부분이므로 스스로 알맞은 OS에 맞는 시그널표를 찾아 참고하기를 바란다
   ### 파이프
   - 파이프는 동일한 시스템의(동일한 컴퓨터의) 두 프로세스 사이에 통신을 할 수 있는 인터페이스 입니다.  
   - IPC는 별도로 뒤에서 다루겠니다.(파이프와 IPC는 비슷하나 다른 개념입니다)
   - 파이프는 단방향성이기에 두 프로세스 사이에 데이터를 주고 받기 위해서는 두개의 파이프가 필요합니다(상항, 하행)
   - 부모 자식 사이에는 이름 없는 파이프를 사용할 수 있으나, 서로 다른 별도의 프로세스 사이에 통신을 위해서는 반드시 이름있는 파이프를 사용하야 합니다
   ### IPC - 인터 프로세스 커뮤니케이션
   - 범용적으로 사용되는 3가지 프로세스 사이의 통신 기법 - 큐-모리-포어(암기용, 이하 큐모리포어)
     1. 큐
     2. 공유메모리
     3. 세마포어
   - 앞으로 3가지 방식에 대하여 다루어 보고자 하기 전 필요한 개념은 바로 Key 개념입니다.
   - Key란? : 큐모리포어를 사용하기 위한 식별자
     - Key또한 파일이며, 프로세서를 구분하기 위한 PID 와 비슷하다고 보면 된다.
   - 큐 메시지 : 큐메시지로 사용되며, 프로세스 사이에 큐 메시지를 기반으로 데이터를 넘겨주거나 받는다.
   - 공유 메모리 : 두개 이상의 프로세스가 동일한 메모리의 공간을 공유
   - 세마포어 : 공유메모리 사용 중 프로그램 간 데이터의 손상을 방지하기 위해서 도입된 기법 : 예를들어 대세대 주택 한층에 화장실 하나를 공유하는데, 서로 다른 세입자(프로세스)가 동시에 메모리(화장실)을 공유하면 문제가 발생(...) 하므로, 이를 방지하기 위해 프로세스가 메모리를 점유 중에는 잠궈놓는 등의 조치를 세마포어라고 이해하자
   -
 ## Day for me 소켓 프로그래밍
   - TCP VS UDP 프로토콜
   - OSI 7레이어? 4레이어? 이에 대한 이해
   - 프로그래밍을 위한 준비사항: IP주소와 호스트 포트번호 이해
   - 소켓 인터페이스 : IPv4, IPv6
   - 소켓 인터페이스 함수
     - socket() : 소켓의 생성 Server only
     - bind() : 소켓을 IP주소, 포트번호와 결합 Server only
     - listen() : 클라이언트 통신준비 완료 Server only
     - connect() : 클라이언트 서버 접속요청 Client only
     - accept() : 연결 수락 Server only
     - recv() : 데이터 수신 TCP
     - send() : 데이터 송신 TCP
     - recvfrom() : 데이터 수신 UPD
     - sendto() : 데이터 송신 UPD
    



  
  
      

