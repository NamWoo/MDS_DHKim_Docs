# 0. 개요
  * 이 문서는 MDS자율주행차 교육과정 4주차 Python(교재명 : 파이썬의 신, 김주현 저) 에 대해 학습한 자료를 공유하는 문서 입니다.
   #
   #### 모든 공부의 출발지 : 필요성
  # 파이썬 학습의 필요성 : Life is too short, You need Python.
   * 파이썬은 쉽다, 파이썬은 간결하다
   * 파이썬이 좋다 나쁘다를 논하는것은 불가능하다. 아래의 글들은 참고하여 각자 판단하자
            
   [파이썬의 장점, 단점 타 언어에 비교, 나무위키](https://namu.wiki/w/Python)
   
   [파이썬으로 개발한 프로그램들의 List](https://github.com/vinta/awesome-python)
   
   #### 파이썬에 대한 생각을 정리하는 몇가지 근거들 
    1. 코드가 간결해지고 배우기 쉽다 (프로그래머 모르게 동작하는 부분이 많다.)
    2. 당신도 python으로 만들어진 프로그램을 사용중이다 : 카카오톡, KiCAD(EDA tool)...
    3. AI / ML / DL 시대에 파이썬을 하는것보다 안하는게 힘들다....
    4. 시간이 짧다 : 입문자가 "Hello"와 "world" 문자열을 +(더하기 연산) 하기까지에 걸리는 
    5. 쉬운 기능구현 : 좀더 쉽게 기능구현이 가능하다  
    6. 교재 365p : 파이썬의 모든 메커니즘을 파해치는 것은 오히려 C언어를 공부하는것보다 어렵다고 본다.(중략) 우리가 프로그래밍을 하는 목적은 이런 내부적인 메커니즘을 공부하는것이 아니라 외부적인 목표를 위한것이다.
   
   * 나의 생각 & 서평 :
     ```
       C/C++을 하던 사람들이 Python을 배우는것은 단순히 언어를 하나 더 배운다, 라는 문장 이상의 의미를 갖는다. 파이썬을 배우는것은 절차지향에서 객체지향으로의 변화만큼이나 큰 페러다임의 변화입니다.

       기존의 C/C++ 는 컴퓨터의 내부에 초점을 두고, CPU,RAM같은 하드웨어들이 추상화되어있는 컴퓨터의 내부 구조를 조금이나마 들여다 볼수 있는 언어이며 컴퓨터가 생각하는 방식, 메모리의 관리에 대하여 이해할수 있습니다. 이런 언어들로는 주로 OS를 만들거나 MCU에서 동작하는 Firmware에 사용됩니다.

       반면에 파이썬의 관점은 컴퓨터의 외부에 초점이 맞춰져 있는 언어입니다. 파이썬으로는 알고리즘과 어플리케이션의 응용 딥러닝 머신러닝으로 새로운 프로그램을 개발하는 목표를 갖고 있습니다.

       상반된 두가지 언어를 하나의 기준과 편협한 관점에서 더 우월한지 열등한지를 비교하는것 자체가 잘못된 생각이라고.. 감히 말씀드리고 싶습니다. 두 언어의 "지향점" 혹은 "목표" 다시말해 강점!!이 다르기에, 상황과 조건에 따라 좀더 수월하고 적절한 언어 or 도구가 있을 뿐이라고 생각합니다.

       밥과 국은 수저로 먹고 면은 젓가락으로 스테이크는 포크와 나이프로 먹는것처럼 파이썬은 C/C++대비 상호베타적인 관계가 아닌, 상호보완적인 관계로 파이썬만의 특징을 살려 공부하였습니다.
       
       마지막으로.. 책과 강의에 대한 평가는 감히.. 이렇게 평가 하고 싶습니다. "C/C++에 대한 향수가 진한 책이였습니다."
     ``` 

  한줄요약 : 파이썬은 당신의 퇴근을 위해서 배워야 합니다.
  
 #
 ## 목차
```
  [ 1부 시작하기 ]
    1장 파이썬 시작 
    2장 미리 알아두기 - 들여쓰기 
    3장 변수와 객체 - 객체 

  [ 2부 내장 데이터 타입 ]
    4장 숫자(numeric) 타입 - 정수타입을 다룰 때 주의사항
    5장 시퀀스(sequence) 타입 - string, list, tuple 
    6장 매핑(mapping) 타입 - 사전자료형과 변환 
    7장 셋(set) 타입 - set의 생성, 특징, 연산, 리스트를 set으로 
ㄴ
  [ 3부 기본 문법 ]
    8장 제어문 - if, for, while
    9장 함수 
    10장 모듈과 패키지 
    11장 클래스 
    12장 파일 다루기 
    13장 예외(exception) 
  
  [ 4부 파이썬의 활용 ]
    14장 GUI(Graphical user interface) 
    15장 멀티쓰레드 프로그래밍 
    16장 네트워크 프로그래밍 
    17장 데이터베이스 
    18장 주요 표준 라이브러리 
```
* 

#
# 1. [ 1부 시작하기 ]
 #
 ## 1장 파이썬 시작 
   - 개발환경 : SublimeText3 + anaconda (OS: Windows10 x64)
   - 파이썬 설치 시 CMD 실행을 위해서 환경변수 등록 혹은 설치시 Option 설정 필요

 #
 ## 2장 미리 알아두기 - 중요 키워드 : ★들여쓰기★ 
   - 리터럴 : 고정된 데이터 ->> C언어에서의 상수(변하지 않는 값)
   - 표현식 : 값을 표현하거나 반환 ->> C언어에서의 변수, C++에서의 인스턴스
   - 구문 : 어떤 목적을 수행하는 코드 (실행문)
   - 들여쓰기★ : for문 혹은 if문의 실행에서 들여쓰기가 매우 중요하다(44p) , 파이썬에서의 들여쓰기는 c언어에서 중괄호(기호:{}, 브레이서)역활을 수행 함
   - 들여쓰기가 강제되는 상황(반복 혹은 분기문)에서 :(콜론) 기호 사용이 필요하다.
  
 #
 ## 3장 변수와 객체 - 중요 키워드 : 객체★ 
   - 변수★★ : 파이썬은 동적 타이핑 언어로써 실행시간에 변수의 데이터타입이 결정된다 
   - 파이썬에서 타입선언 하지 않는 이유 : 객체
   - 참조 대상은 파이썬 객체, 파이썬은 C++와 비교적 유사한 형태로 생각하면 편하다.
   - 파이썬에서 변수가 동작하는 원리는 객체!
   - 정수형 데이터를 사용하더라도 용량이 큰 객체를 사용함 이로인한 단점으로는 느린속도가 필연적이다.
   - 매소드가 많아서(매소드=클래스의 맴버함수) 사용하기 편리하다
   - 파이썬은 모든 데이터를 객체로 처리하기 때문에 메소드가 존재한다. EX)chr, ord
#
# 2. [ 2부 내장 데이터 타입 ]
 #
 ## 4장 숫자(numeric) 타입 -  중요 키워드 : ★정수타입을 다룰 때 주의사항★
   - divmod함수 : 몫과 나머지를 튜플로 리턴
   - (int a)/(int b) 의 연산결과는 float a/b 실수값(소수점 표시)
   - (int a)//(int b) 의 연산결과는 int a/b의 몫(소수점 표시)
   - 복합대입연산 : a//=b 
   - a++같은 문법이 적극 사용되지만 파이썬에서는 허용되지 않음. 
   - 논리연산 (Python과 C언어 비교)
      ```
        C언어     Python
        &&        
        ||
        !
      ```
   - ★★★★★ 정수 타입을 다룰 때 주의사항
     - 파이썬은 내부적으로 많이 사용되는 수인 -5부터 257 까지의 정수객체는 미리 생성 해 놓는다(100p)

   - 104p 정리해봅시다
     ```
     1. 파이썬의 연산자는 /(나눗셈, 실수형)과 //(몫, 정수헝) 두가지가 존재함
     ``` 

 #
 ## 5장 시퀀스(sequence) 타입 
      
   ```
    - 시퀀스타입
    - 문자열 
    - 리스트(list) 
    - 튜플(tuple) 
    - 시퀀스 타입들 간에 변환 
    - non-시퀀스타입
    - 딕셔너리
    - 패킹(packing)과 언패킹(unpacking) 
   ```
   - 시퀀스타입이란 객체간에 순서가 존재한다 -> C언어에서 배열과 비슷
   - 시퀀스타입의 INDEX는 0부터 출발한다
   
   # 
   #### 문자열
   - print에서 개행문자 취소는 아래의 코드를 print문의 괄호 안에 삽입한다.(아래 코드)
   - escape sequence : 굳이 해석하자면 확장문자열 이지만 문자열에서 특수한 기능을 담당하는 예약어들 (\n, \r, \t)
   ```python
    print("개행하지 않는 문자열의 출력",end=" ")
    print("\n") #줄바꿈 문자열
    print("\r") #캐리지 리턴, 커서의 위치를 같은행 맨 앞에
    print("\t") #수평 탭
    print("\r\n") #OS의 특성이나 프로그램의 특성에 구애받지 않고 다음줄 맨앞에 커서가 위치하게 하는 문자열 
   ```
   - 슬라이싱(slicing) !!파이썬의 유용한 기능 : [i:j]
   ```python
    s = "python"
    print(s[0:4]) #pyth
    print(s[:4]) #pyth
    print(s[:-1]) #pytho
    print(s[2:]) #thon
    #주석이 콘솔창의 프린트문
   ```
   - 문자열 포맷팅★ python만의 고유특징! -> 런타임에 type이 동적으로 정해지는 python의 특징을 활용한 기법임
   - 문자열의 메소드들 정리★★★★(128p~132p) 
     1. .upper() / .lower() : 문자열 전체를 대문자 혹은 소문자로 변환
     2. .capitalize() : 문자열의 첫번째 문자를 대문자로 변경
     3. .caseflod() : 문자열을 소문자로 만들거나 문자열 비교를 위한 형태로 변경
     4. .center(width[,filchar]) : 문자열을 형식에 맞게 중앙정렬
     5. .count(sub[,start[,end]]) : 문자열에서 단어의 포함횟수를 반환
     6. .format() : 여러 문자열을 형식에 맞게 연결해줌(c언어의 sprintf()함수와 비슷)
     7. .index(sub[,start [,end]]) : 문자열을 왼쪽부터 검색하여 부분문자열 sub가 최초로 발견된 위치를 반환 
     8. .join() : '/'.join("python")의 경우 출력결과는 'p/y/t/h/o/n'
     9. .strip() : 문자열의 추가 제거 (비슷한 메서드로 istrip, rstrip이 있음)
     10. .split() : 문자열 함수를 리스트 타입으로 변환 join함수와 정반대
     11. .replace() : 
     12. 슬라이스! [:n] 과 [n:] : 
   >> Tip. 여러라인의 문자열을 묶음 처리 할때는 """ 여기부분부터~여기까지는 주석처리 """ (C언어의 /* ~ */)  

   # 
   #### 리스트 
   - 리스트 : 시퀀스타입의 객체로 포함하는 객체들을 순서있게 저장한다. 배열의 업그레이드 버전(어떻게 보면 void * [], void형(만물 자료형) 배열)
   - 리스트만의 특징 : 시퀀스타입이며 내부에 포함하는(이하 내포하는)객체의 제약이 없다, 리스트가 리스트를 내포할 수 있다. (그리고 평가과 수반되는 과정이라면 시험문제에 리스트 활용 문제를 내기 딱 좋다.)
   - 리스트는 서로 다른 자료형을 내포할수 있다. (C언어에서 구조체의 장점을 빼닮았다)
   - 리스트(리스트 인스턴스 혹은 객체는)는 많은 메서드(맴버함수)를 활용할 수 있어 편리하다(근데 이건 python강점인데??, 리스트는 파이썬의 하위항목인데? 파이썬의 장점과 리스트의 장점은 상호포함(상하관계)?? 추후정리필요)
     ```python
      mylist[5, 3.14 , "Python", [1,2,3], ["Fermi" ,"Dirac", "statistics"] ]
      print(mylist[2])
     ```
   - 객체라면 어떤 타입이라도 리스트에 포함될 수 있다.
   - 불변과 가변★
      - mutable 객체 : 객체의 수정과 삭제가 가능함 :  List
      - immutable 객체 : 객체의 수정과 삭제는 불가능 : 튜플, 문자열, 정수
      - 불변과 가변은 변수명에 대입연산이 가능하냐 불가능하느냐의 이야기가 아닌, 객체의 참조번호 변경없이 포함하는 내용의 변경 가능한가 아닌가에 대한 구분
      - .append() 메소드 : List에 항목을 추가할때는 append 메소드를 통해 추가
      - 예시 코드
       ```python
        mylist = [1,2,3,4,5]
        print(id(mylist)) #참조 번호 출력
        mylist.append([100,200,300]) # 리스트를 내포하는 리스트
        print(mylist) # List 출력
        print(id(mylist)) # 참조번호 확인, 변화없음
        mylist.append(300) # append메서드를 활용한 데이터 추가
        print(id(mylist)) # 참조번호 확인, 변화없음
        mylist = 999 # 잘못된 대입연산
        print(mylist)  # 잘못된 대입연산의 결과 데이터 소실
        print(id(mylist)) # 잘못된 대입연산의 결과 참조번호 변화 
       ```
  - 리스트 객체가 사용할 수 있는 메소드(맴버함수)
     1. .del() : 리스트 객체 중 데이터 삭제
     2. .remove() : 리스트 객체의 삭제
     3. .pop() : Stack의 Pop기능과 동일, Last input (맨마지막) First Output
     4. .append() : 위와 동일한 내용이므로 생략
     5. .copy() : 객체에 대해 얕은복사를 수행한다
     6. .sort() : 원본을 변경하여 정렬함(새로운 객체를 생성하지 않음)
     7. sorted() : (내장함수!!) .sort()매소드와 비슷하지만, 다른점은 새로운 객체를 생성한다.
  - 리스트의 얕은복사/깊은복사 문제 : C++의 그것과 비슷하면서 다르다.
    - 차이점은 C++는 깊은 복사 수행시 객체의 모든부분을 복사하지만, python에서의 깊은 복사는 immutable 객체에 대해서만 전체 복사를 수행한다.
    - Python은 기본적으로 모든 데이터를 객체를 참조로 관리한다.(1장에서 언급)
    
   #
   #### 튜플  
   - 튜플은 immutable 객체로 한번 생성되면 내용을 변경할 수 없다.
   - 튜플의 생성
     - mytp = (1,2,3,4)
   - 리스트 대비 튜플을 사용해야 하는 이유 : 리스트와 비교해 튜플의 역할이나 모양이 비슷하지만, 리스트와는 상호보완적 관계이며 3가지를 알아두자
      1. immutable List 라고 생각하자 : 값을 변경할 수 없다.
      2. 리스트의 값이 수정될 필요가 없으면(상수값 배열 등..) 튜플이 리스트보다 좋다.
      3. 위의 항목에서 좋다의 근거는 리스트보다 튜플의 메모리사용이 적고 처리속도 또한 조금더 빠르다.

   #
   #### 시퀀스 타입간의 변환(문자열, 리스트, 튜플간의 변환 : 6가지 경우의 수)
   - 서로간에 변환이 가능하도록 설계되어있음
   - 매서드 (객체 혹은 인스턴스의 맴버함수)를 활용하여 상호변환한다.
   ```python
    #string to list and tuple
    myString = "python"
    print(myString)
    print(list(myString)) ##result : ['p', 'y', 't', 'h', 'o', 'n']
    print(tuple(myString)) ##result : ('p', 'y', 't', 'h', 'o', 'n')
    ##=================================
    #tuple to list and string
    mytyple = (1,2,3,4,5)
    print(mytyple)
    print(list(mytyple))
    print(str(mytyple)) ##result : (1, 2, 3, 4, 5)
    ##=================================
    #list to tuple and string
    mylist = [6,7,8,9,10]
    print(mylist)
    print(tuple(mylist))
    print(str(mylist))
   ```
   -위의 결과에서 tuple to string 혹은 list to string에 실망스러울수 있다. 왜냐하면 "python"이라는 문자열을 튜플(혹은 리스트로) 변환 후 다시 문자열로 변경하면 아래와 같은 결과가 나오기 때문이다.
   - 위와같은 문제를 해결하기 위한 방법(161p) - .split() 매소드
   ```python
    myString = "python"
    myString = tuple(myString)
    myString = str(myString)
    print(myString)
    # result : ('p', 'y', 't', 'h', 'o', 'n')
    # 뭐지 진짜 모르겠다.. 파이썬 빡 공부중..
   ```
   - 5장 정리해봅시다 내가 생각한 답
      1. 시퀀스형 데이터는 0부터 인덱스가 시작한다.
      2. 특수기능 문자열 상수는 "Escape sequence" 이다.
      3. in 연산자를 사용하여 시퀀스 데이터 내부에 어떤 객체가 존재하는지 확인할 수 있다.
      4. 문자열이 시시각각 달라져야 한다면 문자열포멧팅을 사용하자(sprintf기능)
      5. 튜플 리스트에는 다양한 타입이 들어올수 있고, 문자열은 오로지 문자만 들어온다
      6. mutable객체 3대장 : 튜플, 문자열, 숫자
      7. 리스트에 iterable객체 항목추가 두가지 : extend, +=
      
      (8 & 9 번 항목은 각자)
   - 
  #
  ## 6장 매핑(mapping) 타입 - 사전의 생성, 특징, 연산, 리스트로 변환, 사전으로 변환 
   - 사전의 중요한 특징 : 사전은 순서(시퀀스가 없다)는 없다, Non-sequence한 객체이다.
   - 키값은 고유하며 중복될 수 없다.
   - 사전(dict)의 Key값은 immutable한 객체이다.
   - dictonary의 Method
      1. .index() : 메핑된 데이터를 조회
      2. .update() : 매핑된 데이터를 업데이트
      3. .setdefault() : 기존값이 없다면 추가하고, 존재하면 업데이트 하지않음
      4. .del() : 
      
  #
  ## 7장 셋(set) 타입 - set의 생성, 특징, 연산, 리스트를 set으로 
   - 수학에서의 집합과 동일함
   - 항목간에 순서가 존재하지 않는다
   - 중복을 허용하지 않는다(사전과 동일)
   - list to set하는 방법
      - sorted() 내장함수 사용(203p)

#
# 3부 기본 문법 
 #
 ## 8장 제어문 
 - 제어문은 크게 3가지로 나뉜다
    1. if,elif,else
    2. for문,while문, 리스트 생성
    3. 기타문법 
 - elif가 else if를 대체한다.
 - for문
    - C언어의 그것과 비슷하며 구구단 예제를 보이면 아래와 같다.
     ```PYTHON    
      for x in range (1,10):
          print()
          for y in range (1,10): 
              print("%d*%d = %d \t" %(x,y,x*y),end=' ')
     ```
 - 유일하게 주의할점은 Python은 들여쓰기에 매우 민감한 언어이며, Tab 혹은 Sapce중 한가지만을 사용하여야 한다. 
 - 파이썬의 강점을 잘 활용할 수 있는  
    1. Conditional expression(조건표현식,219p) 
        ```py
        # A if 조건식 else B
        print("ON") if switch == 1 else print("OFF")
        ``` 
    2.  Overlapped Conditional expression(중첩 조건 표현식,221p)
        ```py
        # A if 조건식 else B if 조건식 else C
        print("Btn1") if button==1 else print("Btn2") if button==2 else print("other Btn")
        ``` 
    3. dictory traverse(사전 자료형을 활용한 순회,228p)
        ```py
        my_dict = {'a' = 65, 'b' = 66, 'c' = 67, 'd' = 68}
        for k in my_dict
          print(k)
          # 실행할 때마다 출력되는 순서가 변경된다! 기억하자 사전자료형에 순서는 존재하지 않는다.
        ```
    4. list comprehension(리스트 내포,235p)
        ```py
        my_list=[]
        for x in range (1,10):
          my_list.append(x)
        print(my_list)
        ```
    5. Overlapped list comprehension(중첩 리스트 내포,237p)
        ```py
        my_list=[]
        for x in range (1,10):
          for y in range (1,10):
            print("%d*%d=%d\t"%(x,y,x*y),end=' ')#구구단 출력
            my_list.append(x*y)#구구단 리스트의 저장
          print("")
        print(my_list)#리스트의 출력
        ```    
    6. 하지말아야할것 : C-Style pycode
        ```py
        my_list = []
        my_list[0] = 'A' #syntex error 발생
        ```
ㄴ
 #
 ## 9장 함수 
  * 함수의 정의 ,호출, 인수, 전달방식 ,인수 정의 순서 
    return ,scope, namespace, 중첩함수  
  * 함수의 3가지 구성요소 
      1. 원형의 선언(prototyping)
      2. 함수 호출
      3. 함수의 정의(함수의 구현)
  * 함수 선언 시 주의 사항
      1. 함수의 호출을 위해서는 호출자 file에서 원형과 호출은 항상 같이 존재해야 한다.
          * 동일한 이유로 C에서는 xx.h파일을 include한다
      2. 함수의 원형이 호출과 동일한 파일에 존재해야 하는 이유는 컴파일러에게 함수의 원형이 존재한다고 명시적으로 알려주는 역활을 한다. 함수의 호출과 원형의 연결은 컴파일러에서 담당한다
      3. 실제 함수의 정의와 구현내용은 Linker에서 담당한다. 링커는 전체 컴파일 과정 마지막에서 각 파일별로 동일한 함수명과 글로벌변수 및 메모리맵등을 하나의 파일로 묶어주는 역활을 수행 한다.
  * 함수에서 return의 두가지 기능
      1. 함수의 종료
      2. 리턴값의 반환
  * 함수의 영역과 내장함수 : 파이썬에서 변수의 영역은 3가지 LGB 3가지이며, 서로 계층적으로 분리된 영역이다. 파이썬의 스코핑 룰에 대한 학습이 필요하다(266p)
      1. L : Local -> 함수 내부
      2. G : Golbal -> 전역변수
      3. B : Built-in -> 파이썬 내장함수

  * 함수 내에서 전역변수를 사용하고 싶다면 사용할 키워드 : global
  * 여러 영역에서 동일한 이름의 함수명을 사용하는 프로그래밍 습관은 매우 나쁨. 
  * 람다 표현식(ㅜ..ㅜ) 
      1. C++에서의 람다함수와 매우 유사함
      2. 람다 표현식은 반복문이나 조건문 같은 제어문은 포함될 수 없다.
      3. 한줄짜리 표현식으로만 이루어진다.
      4. 람다 표현삭 + list를 이용해서 함수포인터와 유사한 기능을 구현할 수 있다.
      5. 람다 표현식은 따로 정의를 두지도 않고 이름도 가지고있지 않다. 
      6. 람다표현식은 익명함수이다.
      7. 간단한 수식의 경우 람다함수를 사용하는것이 간단하고 가독성도 좋다.

  * 클로저 : 전역변수 남발을 방지하고 안전하지 않은 상태를 제거하기 위해 나옴
      * 외부의 함수를 불러들이면 그 함수는 자신이 정의된 환경에 대한 정보까지 같이 묶어서 불려들여진다. 함수와 함수에 대한 정보를 아우른 것이 클로져
  * 데코레이터(장식자) : 파이썬 디자인패턴의 한 종류(추후 수정/보완 요망 2019-06-09)
  * 9장 함수 정리문제
      1. 함수에서 여러값을 동시에 반환할때 사용하는 자료형 : 튜플
      2. 파이썬이 변수를 검색하는 스코핑 룰 : LGB스코핑 룰
      3. 함수를 구현하지 못했을때, 인터페이스 상태에서의 테스트를 위한 키워드 : pass

#     
## 10장 모듈과 패키지 
  * 파이썬에서의 모듈은 하나의 파일이며, 지금껏 만들어온 모든 파이썬파일들이 하나의 메인함수도 될수 있고 모듈도 될 수 있다.
  * 직접 실행되는 파이썬코드에서 (언더바언더바)name(언더바언더바) 는(언더바언더바)main(언더바언더바) 의 값을 가지고 있다(추후 수정 예정 2019-06-09)
  * 파이썬 모듈을 불러들일때 사용하는 키워드 : import

#
## 11장 클래스 
  * 객체지향은 프로그래밍 방법론을 뛰어넘어서는, 프로그래밍 페러다임의 전환
  * 객체지향을 이루는 근간은 클래스이며, 클래스를 기반으로 object(객체)를 생성한다. 이러한 객체들 사이의 관계와 속성, 행위에 대하여 정의하는 방식이 객체지향(oop, object oriented Prog)입니다.
  * 객체지향의 장점  
      1. 캡슐화 : 맴버변수 + 함수(데이터와 기능의 구현)
      2. 정보 은닉 : 외부에서 내부의 중요데이터에 접근해 발생할 수 있는 사고를 방지
  * 객체에서의 3가지 변수의 속성
      1. 클래스 속성변수
      2. 인스턴스 속성변수
      3. 인스턴스 내부의 로컬변수
      * 기본으로 지역변수와 로컬변수또한 기존과 동일하게 존재한다
  * 파이썬에서의 객체지향에서 중요한점 : C++ 처럼 생각하지 말자
      1. 파이썬에 익숙하지 않다면 -> 생성자가 여러번 호출되는거 신경쓰지말자 파이썬이니까
      2. 파에썬의 객체지향은 내부 구조에 대하여 깊게 알 필요가 없다. 
      3. 위 문장은 파이썬에 익숙한 사람이라면 틀린문장이다. 하지만  파이썬 고수들은 이 문서를 읽고있으면 안된다 (볼 필요가 없다)
      4. 메모리가 좀 더 먹거나 실행속도가 느려지는것에 신경쓰지말자 -> 이해가 되지 않는다면 서두에 밝힌 파이썬의 지향점과 강점에 대해 다시 읽어보자
      5. 하고싶은말이 있다.
      ~~~
       C++ 명저로 손꼽히는 Effective C++ 에 보면 첫번째 쳅터에 " C++에 왔으면 C++ 문법을 따릅시다" 라는 구절이 있다. 주어가 생략되어있지만, 아마도 "이런 C밖에 모르는 인간들아" 정도라고 추측이 된다.
       파이썬도 마찬가지이다. 파이썬의 객체지향은 쉽고 빠르다 하지만 꽁짜로 쉽고 빨라진것은 아니며 그만큼의 댓가를 치루고 있는 중이다(당신의 콤퓨타 나의 맥북!) 파이썬의 객체지향과 클래스가 내부적으로 어떤 동작을 하는데에 자세히 배우기보다는, 쉽고 빠르게 구현해서 새로운것을 창조해 내는 방향으로 인식의 전환을 해보는것은 어떨까?? 추상화로 인해 코드 레벨에서 보이지않는 동작은 C/C++에서 집중할것을 권한다
      ~~~
  * 인스턴스란 메모리에 실존하는 객체를 이르는 말 : 실제로 메모리에 할당된 객체
  * Python에서는 Constructor 가 존재하지 않는다.
  * @classmethod의 의미 : (추후 추가해야하는 부분)
  * 스테틱 메소드 : 정보 은닉의 개념
  * 네임 맹글링 : 파이썬에서 최소화된 정보 은닉기법
  * 상속 : 부모클래스의 자원을 자식클래스에서 물려받아 활용할 수 있는 객체지향의 핵심 기법
  * 메소드 오버라이딩 : 자식함수에서 부모함수의 메서드(맴버함수)를 재 정의하여 다른 기능을 수행할 수 있게 변경하는 기법
  * 연산자 오버로링 : 연산자의 중복을 허용하는 기능 동일한 연산기호를 타입에 따라 다른 의미로 사용할 수 있는 기능
  * Class의 속성변수 접근 방법 2가지
      1. cls키워드 사용
      2. class이름.변수명


  * 클래스의 메소드를 정의할 때 첫번째 인수로 self키워드를 사용하는 의미는 같은 클래스로브터 생성된 객체들은 메소드를 공유하기 때문에, 호출된 메소드가 자신을 호출한 객체를 식별할 필요가 있어서이다 (이해안됨..)
  * 모든 객체는 자신만의 이름공간(namespace)를 갖는다
 # 
 ## 12장 파일 다루기 
   * 파일접근모드 4가지 : r,w,a,x (408p)
   * 파일포인터의 위치반환메서드 tell
   * 쓰기 후 읽기 하기전 필요한(관례 상 호출해야만 하는) 메서드 : fflush
   * 읽기 후 쓰기를 하기 전 필요한(관례 상 호출 해야만 하는) 메서드 : Seek
   * char to binary : 인코딩
   * binary to char : 디코딩

 
 #
 ## 13장 예외(exception) 
   * try, except, catch

 #
 ## 14장 GUI(Graphical user interface) 
   * 파이썬의 기본 GUI FrameWork인 tkinter 사용
   * tkinter의 메서드들 정리
      1. .Entry() : 텍스트를 입력할 수 있는 창
      2. .Canvas() : 도형을 그릴 수 있는 바탕 객체 생성(Liks as 도화지)
      3. .Text() : 메모장 메서드 생성
      4. 
      5. 
      6. 
      7. 
      8. 
      9. 
      10. 

  * 많은 수업이, 많은 프로젝트가 그렇듯 용두사미가 되는 경우가 많은데, 지금이 그렇습니다.
  마지막까지 최선을 다하지 못한 제 자신에게 위로와 회초리를..